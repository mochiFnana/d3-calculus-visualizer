<!DOCTYPE html>
<html>
<head>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<style>
		.display {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
		}
		#settings {
			width: 100%;
			display: flex;
			flex-direction: column;
		}
		input {
			flex-grow: 1;
		}
	</style>
	<title>
		Interactive Function and Derivative Visualizer
	</title>
</head>
<body>
<script>;
		// Array to hold the data points for the main function graph (f(x))
		let graph;
		// Array to hold the data points for the derivative function graph (f'(x))
		let grapd;

		/**
		* Initializes the min, max, step, and current value for a range input slider.
		*/
		function infun(id, a, b, c) {
			id.min = a - b[0];
			id.max = a + b[1];
			id.step = c;
			id.value = a;
		};
		
		/**
		* Recalculates all data points for the main function and derivative based on current parameters (k and g).
		*/
		function n3w() {
			graph = [];
			grapd = [];
			// Iterate across the full range defined by val[1] (e.g., -360 to +360)
			for (let i = -val[1][0]; i <= val[1][1]; i += val[2]) {
				graph.push({
					x: i,
					y: cal(i)
				});
				grapd.push({
					x: i,
					y: dal(i)
				});
			};
		};
		
		/**
		 * Simplified function to find the max or min value across both data arrays.
		 * @param {Array<Array<Object>>} a - The combined data array ([graph, grapd]).
		 * @param {number} b - Comparison type (1 or >= 1 for max, < 1 for min). Default is 1 (max).
		 * @param {string} c - Coordinate to check ("y" or "x"). Default is "y".
		 * @returns {number} The min or max value for the specified coordinate.
		 */
		lar = (a, b = 1, c = "y") => {
			let ret = a[0].concat(a[1]); // Combine data arrays
			// Check if looking for max (b >= 1) or min (b < 1)
			return (b >= 1) ? 
				// Max logic: check x or y
				((c === "y") ? d3.max(ret, d => d.y): d3.max(ret, d => d.x)): 
				// Min logic: check x or y
				((c === "y") ? d3.min(ret, d => d.y): d3.min(ret, d => d.x));
		};
		
		/**
		* Calculates the sine of an angle (a) given in degrees.
		*/
		sin = (a) => {
			return Math.sin(a * (Math.PI / 180));
		};
		
		/**
		* Calculates the cosine of an angle (a) given in degrees.
		*/
		cos = (a) => {
			return Math.cos(a * (Math.PI / 180));
		};
		
		// Define base chart margins
		let margin = {
			top: 10,
			bot: 0,
			lef: 10,
			rig: 10
		};
		// Define total width based on screen width for responsive design
		const Twidth = screen.width;
		const Theight = 140;
		
		// Calculate responsive margins based on percentage of Twidth and Theight
		Object.entries(margin).forEach(([a, b])=> {
			if (["lef", "rig"].includes(a)) {
				margin[a] = (Twidth/100)*b;
			} else if (["top"].includes(a)) {
				margin[a] = (Theight/100)*b;
			} else {
				// Calculate bottom margin based on left margin
				margin.bot = margin.lef*3.5 
			}
		})
		
		// Calculate inner drawing area dimensions
		const width = Twidth - margin.lef - margin.rig;
		const height = Theight - margin.top - margin.bot;
		
		// Get the angle slider element
		const slider = document.getElementById("angle-slider");
		// Define the range [initial, [min_x_range, max_x_range], step]
		const val = [0, [360, 360], .5];
		
		// Ensure step is at least 0.5
		val[2] = (val[2] < .5) ? .5: val[2]
		// Initialize the angle slider (domain is from -360 to 360)
		infun(slider, val[0], [val[1][0], val[1][1]], val[2]);

		const value = document.getElementById("current");
		
		// K-Setting: Controls vertical shift (y-offset)
		const kset = document.getElementById("kchange");
		let k = 0;
		infun(kset, k, [10, 10], .01);
		
		// G-Setting: Controls exponent (x^g) inside the cosine function
		const gset = document.getElementById("gchange");
		let g = 0;
		// Slider range for g is 0 to Pi (approx 3.14)
		infun(gset, g, [0, Math.PI], .001);
		
		const linel = 20;
		
		/**
		 * The main parameterized function: f(a) = cos(|a|^g) + k/2
		 */
		cal = (a) => {
			// Returns: cos(|a| raised to power g) + (k / 2)
			return (cos(Math.abs(a)**g)+k/2);
		};
		
		/**
		 * The derivative of the main function: f'(a)
		 * Uses the Chain Rule and the derivative of cos(u) = -sin(u) * u'
		 */
		dal = (a) => {
			if (a === 0) return 0; // Handle singularity at x=0 (derivative is undefined or 0 depending on g)
			
			const absa = Math.abs(a); // |a|
			const cos_prime_term = -sin(absa**g); // Derivative of outer cos(|a|^g) is -sin(|a|^g)
			const inner_prime_term = g * absa**(g-1); // Derivative of inner |a|^g is g * |a|^(g-1)
			const sign_term = a / absa; // Derivative of |a| is a/|a| (the sign of a)
			
			// Full Chain Rule application, divided by 2 (matching the k/2 offset in 'cal')
			return (cos_prime_term * inner_prime_term * sign_term)/2;
		};
		
		/**
		* Calculates the angle of the tangent line at a specific point on the main graph.
		*/
		function getTangentAngle(currentAngle) {
			const currentIndex = graph.findIndex(d => d.x === currentAngle);
			const currentPoint = graph[currentIndex];
			const nextPoint = graph[currentIndex + 1];
			if (!currentPoint || !nextPoint) return 0;
			const dx = xScale(nextPoint.x) - xScale(currentPoint.x);
			const dy = yScale(nextPoint.y) - yScale(currentPoint.y);
			// Returns the angle in radians using atan2 for quadrant correctness
			return Math.atan2(dy, dx);
		};
		
		// Initialize the data arrays
		n3w();
		
		// Array to hold the single point being highlighted/tracked
		let current = [{
			x: 0,
			y: cal(0)
		}];
		
		// Select the chart div and append the main SVG container
		const svg = d3.select("#chart")
		.append("svg")
		.attr("width", Twidth)
		.attr("height", Theight)
		.append("g") // Append a group element for margins/translation
		.attr("transform", `translate(${margin.lef}, ${margin.top})`);
		
		// Define the X-axis linear scale
		const xScale = d3.scaleLinear()
		// Domain from the minimum x to the maximum x using lar function (min_x is -val[1][0] which is -360)
		.domain([-val[1][0], lar([graph, grapd], b = 1, c = "x")])
		.range([0, width]);
		
		// Define the Y-axis linear scale
		const yScale = d3.scaleLinear()
		// Domain from the minimum y to the maximum y using lar function
		.domain([lar([graph, grapd], 0), lar([graph, grapd])])
		.range([height, 0]);
		
		/**
		* Calculates the coordinates for the tangent line, centered at the current point.
		*/
		dgrap = (angleRad) => {
			const L = linel; // Half the length of the tangent line;
			const centerX = xScale(current[0].x);
			const centerY = yScale(current[0].y);
			return {
				x1: centerX - L * Math.cos(angleRad),
				y1: centerY - L * Math.sin(angleRad),
				x2: centerX + L * Math.cos(angleRad),
				y2: centerY + L * Math.sin(angleRad)
			};
		};
		
		// D3 line generator for converting data points to path 'd' attribute
		const lineGenerator = d3.line()
		.x(d => xScale(d.x))
		.y(d => yScale(d.y));
		
		// D3 axis generators
		let xAxis = d3.axisBottom(xScale);
		let yAxis = d3.axisLeft(yScale);
		
		// Draw the main function curve (f(x)) in red
		const baka = svg.append("path")
		.datum(graph)
		.attr("fill", "none")
		.attr("stroke", "red")
		.attr("stroke-width", 1)
		.attr("d", lineGenerator);
		
		// Draw the derivative function curve (f'(x)) in blue
		const baki = svg.append("path")
		.datum(grapd)
		.attr("fill", "none")
		.attr("stroke", "blue")
		.attr("stroke-width", 1)
		.attr("d", lineGenerator);
		
		// Draw the X-axis at the center (y=0 line)
		svg.append("g")
		.attr("class", "x Axis")
		.attr("transform", `translate(0, ${height/2})`)
		.call(xAxis);
		
		// Draw a second X-axis at the bottom (height)
		svg.append("g")
		.attr("class", "x Axis")
		.attr("transform", `translate(0, ${height})`)
		.call(xAxis);
		
		// Draw the Y-axis
		const naku = svg.append("g")
		.attr("class", "y Axis")
		.call(yAxis);
		
		// Draw the highlight circle (the moving point)
		const highlightCircle = svg.selectAll(".highlight-circle")
		.data(current)
		.enter()
		.append("circle")
		.attr("class", "highight")
		.attr("r", .75)
		.attr("fill", "#412dff")
		.attr("stroke", "black");
		
		// Initial calculation and drawing of the tangent line
		let io = dgrap(0);
		const line = svg.append("line")
		.attr("class", "line")
		.attr("stroke", "#57009b8c")
		.attr("stroke-width", 1.3)
		.attr("x1", io.x1)
		.attr("y1", io.y1)
		.attr("x2", io.x2)
		.attr("y2", io.y2);
		
		// Draw the vertical guide line (vlin)
		const vlin = svg.append("line")
		.attr("class", "vlin")
		.attr("stroke", "#57009b8c")
		.attr("stroke-width", .5)
		// Initial coordinates
		.attr("x1", xScale(current[0].x))
		.attr("y1", yScale(lar([graph, grapd], 0)))
		.attr("x2", xScale(current[0].x))
		.attr("y2", yScale(lar([graph, grapd])));
		
		/**
		* Updates the position of the highlight circle, tangent line, and vertical guide line.
		* @param {number} newAngle - The new x-value.
		* @param {boolean} uli - Flag to update the vertical line (optimization, only needed on slider input).
		*/
		function update(newAngle, uli = false) {
			const newY = cal(newAngle);
			current[0].x = newAngle;
			current[0].y = newY;
			const angleInRadians = getTangentAngle(newAngle);
			const usagi = dgrap(angleInRadians);
			
			// Update tangent line coordinates
			line
			.attr("x1", usagi.x1)
			.attr("y1", usagi.y1)
			.attr("x2", usagi.x2)
			.attr("y2", usagi.y2);
			
			// Optimization: Update vertical line only if uli is true (i.e., when the Angle Slider moves)
			if (uli) {
				vlin
				.attr("x1", xScale(current[0].x))
				.attr("y1", yScale(lar([graph, grapd], 0)))
				.attr("x2", xScale(current[0].x))
				.attr("y2", yScale(lar([graph, grapd])));
			}
			
			// Update highlight circle position
			highlightCircle
			.attr("cx", xScale(current[0].x))
			.attr("cy", yScale(current[0].y))
			
			// Update displayed text
			value.textContent = `x = ${newAngle}  |||  y = ${newY}`;
		};
		
		/**
		* Handles parameter changes (K or G). Recalculates all data, updates the scales, and redraws the curves.
		*/
		function GeneralUpdate(angle) {
			n3w(); // Recalculate all data points
			
			// Update the Y-scale domain based on the new data range
			yScale
			.domain([lar([graph, grapd], 0), lar([graph, grapd])]);
			
			// Redraw the main function curve
			baka
			.datum(graph)
			.attr("d", lineGenerator);
			
			// Redraw the derivative curve
			baki
			.datum(grapd)
			.attr("d", lineGenerator);
			
			// Redraw the Y-axis with the new scale
			naku.call(yAxis);
			
			// Update the point and tangent line
			update(angle, true); // Use 'true' to ensure the vertical line updates its height if scales changed
		};
		
		// Event listener for the angle slider
		slider.addEventListener("input", (e) => {
			const angle = +e.target.value;
			update(angle, true); // Update vertical line
		});
		
		// Event listener for the K-setting slider (vertical shift)
		kset.addEventListener("input", (e) => {
			k = +e.target.value;
			GeneralUpdate(current[0].x);
		});
		
		// Event listener for the G-setting slider (exponent power)
		gset.addEventListener("input", (e) => {
			g = +e.target.value;
			GeneralUpdate(current[0].x);
		});
		
		// Initial drawing and placement
		update(val[0]);
	</script>
</body>
</html>
